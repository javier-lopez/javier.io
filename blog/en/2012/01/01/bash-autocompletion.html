<!DOCTYPE html>
<html>
  <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta name="keywords" content="Javier López personal blog">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>bash autocompletion | javier.io</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="bash autocompletion" />
<meta name="author" content="Javier López" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="bash autocompletion" />
<meta property="og:description" content="bash autocompletion" />
<link rel="canonical" href="javier.io/blog/en/2012/01/01/bash-autocompletion.html" />
<meta property="og:url" content="javier.io/blog/en/2012/01/01/bash-autocompletion.html" />
<meta property="og:site_name" content="javier.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-01-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="bash autocompletion" />
<meta name="twitter:site" content="@javier_flpz" />
<meta name="twitter:creator" content="@Javier López" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Javier López"},"dateModified":"2012-01-01T00:00:00+00:00","datePublished":"2012-01-01T00:00:00+00:00","description":"bash autocompletion","headline":"bash autocompletion","mainEntityOfPage":{"@type":"WebPage","@id":"javier.io/blog/en/2012/01/01/bash-autocompletion.html"},"url":"javier.io/blog/en/2012/01/01/bash-autocompletion.html"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" href="//javier.io/favicon.ico">
    <link href='//fonts.googleapis.com/css?family=Exo+2:200|PT+Sans|Strait|Vollkorn|' rel='stylesheet' type='text/css'>
    <!--<link href='//fonts.googleapis.com/css?family=Megrim|Ruluko|Exo+2:200|PT+Sans|Strait|Vollkorn|' rel='stylesheet' type='text/css'>-->
    <link rel="alternate" type="application/atom+xml" href="/atom.xml">
    <link rel="stylesheet" type="text/css" href="/assets/css/default_black.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/responsive.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/fontawesome.min.css">

    <!-- syntax http://shjs.sourceforge.net/-->
    <link type="text/css" rel="stylesheet" href="/assets/css/shjs/sh_darkness.css">

    <title>bash autocompletion</title>
  </head>

  <body onload="sh_highlightDocument('/assets/js/lang/', '.js');">
    <div id="header">
  <h1><a href="/blog/">Javier L&oacute;pez</a>
    <form>
      <input type="text" id="st-search-input" class="st-search-input"/>
    </form>
  </h1>

  <a href="/blog/en.html" class="red">[EN]</a> |
  <a href="/blog/pt.html" class="green">[PT]</a> |
  <a href="/blog/es.html" class="yellow">[ES]</a> |
  <a href="/atom.xml" class="rss">RSS</a> |

  

  <!-- Begin Swifttype -->
  <script type="text/javascript">
    var Swiftype = window.Swiftype || {};
    (function() {
      Swiftype.key = 'k64dV6Rm9QK4z8WnkrcN';
      Swiftype.inputElement = '#st-search-input';
      Swiftype.resultContainingElement = '#st-results-container';
      Swiftype.attachElement = '#st-search-input';
      Swiftype.renderStyle = "new_page";
      Swiftype.resultPageURL = "/blog/results/";

      var script = document.createElement('script');
      script.type = 'text/javascript';
      script.async = true;
      script.src = "//swiftype.com/embed.js";
      var entry = document.getElementsByTagName('script')[0];
      entry.parentNode.insertBefore(script, entry);
    }());
  </script>
  <!-- End Swifttype -->


</div>


    <div id="content">
      <div id="post">
  <h2 id="bash-autocompletion">bash autocompletion</h2>

<h6 id="01-jan-2012">01 Jan 2012</h6>

<!--**[![](/assets/img/54.jpg)](/assets/img/54.jpg)**-->

<p><strong>Update:</strong> It’s highly recommended to upgrade <a href="https://viajemotu.wordpress.com/2013/10/16/upgrade-to-bash-completion-2-0/">bash-completion</a> to version &gt;= 2.0 for an improved performance.</p>

<p>I really like minimalism systems (and cli apps), they are faster, more stable and easier to control. I think it’s pretty cool to be able to write a command and get without hesitation a result (I’m aware I’m probably already deprecated, in a world where touch and gui applications are the norm, who would still prefer text based systems?). Sadly many of these commands are not specially user friendly, they contain tons of options and sometimes these options are quite hard to write correctly, when you download scripts from Internet it gets worse, all options must be written by hand because the lack autocompletion.</p>

<p>Many people don’t realize this autocompletion magic work by programming simple bash scripts, so I decided to write a few notes about the process.</p>

<h3 id="introduction">Introduction</h3>

<p>Bash triage autocompletion every time an user press <strong>&lt;Tab&gt;&lt;Tab&gt;</strong>, for most simple commands a single call to <strong>complete</strong> would be enough to generate correct alternatives. Let’s suppose <strong>foo</strong> is a command who only take directories as arguments, the autocompletion logic can be described as:</p>

<pre class="sh_sh">
$ complete -o plusdirs foo
</pre>

<p>From then on <strong>$ foo &lt;Tab&gt;&lt;Tab&gt;</strong> will return a directory list, that one was easy 😉 Now, let’s give more examples:</p>

<pre class="sh_sh">
$ complete -A user bar #will autocomplete bar with a list of system users
$ complete -W "-v --verbose -h" wop #will autocomplete wop with "-v", "--verbose" and "-h"
$ complete -f -X '!*.[pP][dD][fF]' evince foo #will autocomplete evince and foo with all pdf files
</pre>

<p>The full syntax for <strong>complete</strong> can be reviewed in the bash help, <strong>$ man bash</strong></p>

<h3 id="function-based">Function based</h3>

<p>One of the options <strong>complete</strong> accept is <strong>-F</strong> who calls a function, this function can be programmed at any length ✌ e.g:</p>

<pre class="sh_sh">
$ source file_where_pump_function_is_defined
$ complete -F \_pump pump
</pre>

<p>Now whenever pump is typed followed by &lt;Tab&gt;&lt;Tab&gt; <strong>_primp()</strong> will be called and will require to fill the <a href="http://www.gnu.org/software/bash/manual/html_node/Bash-Variables.html">COMPREPLY</a> array.</p>

<p>Most of the files who contain these functions live in <strong>/etc/bash_completion.d/</strong> and in recent years in <strong>/usr/share/bash-completion/completions/</strong> (in Debian/Ubuntu systems), let’s suppose we’ve the following hand made script:</p>

<pre class="sh_sh">
$ fix -h
Usage: fix module
   -h  or --help     List available arguments and usage (this message).
   -v  or --version  print version.
   apache            poves /etc/init.d/apache2.1 to apache2.
   ipw2200           restart the ipw2200 module.
   wl                restart the wl module.
   iwlagn            restart the iwlagn module.
   mpd               restart mpd.
</pre>

<p>The autocompletion logic can be defined in two ways, the easiest one would be to dump the following line in <strong>/etc/bash_completion.d/fix.autocp</strong>:</p>

<pre class="sh_sh">
$ complete -W "-h --help -v --version apache ipw2200 wl iwlagn mpd" fix
</pre>

<p>After doing, it would be necessary to reload the environment:</p>

<pre class="sh_sh">
$ source $HOME/.bashrc
</pre>

<p>WARNING: autocompletion will only work if it’s initialized in <strong>$HOME/.bashrc</strong> or other files read by bash (it also must be installed $ sudo apt-get install bash-completion):</p>

<pre class="sh_sh">
if [ -f /etc/bash_completion ]; then
    source /etc/bash_completion
fi
</pre>

<p>The more elaborated case would involve defining a function, let’s replace the <strong>/etc/bash_completion.d/fix.autocp</strong> content with this:</p>

<pre class="sh_sh">
\_fix()
{

    if ! command -v "fix" &gt;/dev/null 2&gt;&amp;1; then
        return
    fi

    #defining local vars
    local cur prev words cword
    _init_completion || return #comment this line for bash-completion &lt;2.0

    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    COMPREPLY=() #clean out last completions, important!

    COMMANDS="apache ipw2200 wl iwlagn mpd"
    OPTS="-h --help -v --version"

    case "${cur}" in #if the current word have a '-' at the beginning..
        -*) completions="${OPTS}"     ;;
        *)  completions="${COMMANDS}" ;;
    esac
    COMPREPLY=($(compgen -W "${completions}" -- ${cur}))
    return 0
}
complete -F \_fix fix
</pre>

<p>The <strong>$cur</strong> variable is important, parameters would be compared against it, in more complex examples, <strong>$prev</strong> and even <strong>$prev_prev</strong> can be compared.</p>

<p>To generate option lists, <strong>compgen</strong> is used regularly, this command compare and return matched results as a list, to wrap it up, here are some examples:</p>

<pre class="sh_sh">
$ compgen -W "-v --verbose -h --help" -- "-v"
-v
$ compgen -W "-v --verbose -h --help" -- "--"
--verbose
--help
$ compgen -W "apache ipw2200 iwlagn mpd wl" -- "ap"
apache
$ compgen -W "apache ipw2200 iwlagn mpd wl" -- "i"
ipw2200
iwlagn
</pre>

<p>Once this two step process is understood it’s easy to see how most autocomplation scripts work. I’ll review a more complex example, <strong>android</strong>:</p>

<pre class="sh_sh">
$ android -h
  Usage: android [global options] action [action options]
  Global options:
      -v --verbose  Verbose mode: errors, warnings and informational messages are printed.
      -h --help     Help on a specific command.
      -s --silent   Silent mode: only errors are printed out.
  Valid actions are composed of a verb and an optional direct object:
      -   list
      -   list avd
      -   list target
      - create avd
      -   move avd
      - delete avd
      - update avd
      - create project
      - update project
      - create test-project
      - update test-project
      - create lib-project
      - update lib-project
      - update adb
      - update sdk
</pre>

<p>As it can be noted most options depend of a previous command, “avd” should only be returned when list is used as an action:</p>

<pre class="sh_sh">
$ android list[Tab][Tab]
</pre>

<p>And <strong>avd</strong>/<strong>target</strong> should be returned when no substring is present after list</p>

<pre class="sh_sh">
$ android create[Tab][Tab]
</pre>

<p>Should return <strong>avd</strong>, <strong>project</strong>, <strong>test-project</strong> and <strong>lib-project</strong>:</p>

<pre class="sh_sh">
$ android create avd[Tab][Tab]
</pre>

<p>And <strong>-a</strong>, <strong>-c</strong>, <strong>-f</strong>, etc, should be returned when avd and create are the first parameters. The full autocompletion file for this example is located in <a href="https://github.com/javier-lopez/learn/blob/master/autocp/completions/android">github</a>, I’ll explain now the more important parts:</p>

<pre class="sh_sh">
\_android()
{
    if ! command -v "android" &gt;/dev/null 2&gt;&amp;1; then
        return
    fi
    COMPREPLY=() #clean out last completions, important!
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    number_of_words=${#COMP_WORDS[@]}

    if [ "${number_of_words}" -gt "2" ]]; then
        prev_prev="${COMP_WORDS[COMP_CWORD-2]}"
    fi
</pre>

<p>A <strong>prev_prev</strong> variable is declared only when two or more arguments are written in the prompt.</p>

<pre class="sh_sh">
#=======================================================
#                  General options
#=======================================================
COMMANDS="list create move delete update"
#COMMANDS=`android -h | grep '^-' | sed -r 's/: .*//' \
           | awk '{print $2}' | sort | uniq 2&gt; /dev/null`
</pre>

<p>List options can be declared fixed or generated at run time by parsing help screens, depending of the command you can use whenever method feels more comfortable.</p>

<pre class="sh_sh">
OPTS="-h --help -v --verbose -s --silent"
#=======================================================
#                   Nested options [1st layer]
#=======================================================
list_opts="avd target"
create_opts="avd project test-project lib-project"
move_opts="avd"...
</pre>

<p>The same can be set for subcommands</p>

<pre class="sh_sh">
#=======================================================
#                   Nested options [2nd layer]
#=======================================================
create_avd_opts="-c --sdcard -t --target -n --name -a \
                 --snapshot -p --path -f -s --skin"
create_project_opts="-n --name -t --target -p --path -k \
                     --package -a --activity"
create_test-project_opts="-p --path -m --main -n --name"
create_lib-project_opts="-n --name -p --path -t --target \
                         -k --package"...
</pre>

<p>And subcommand options…</p>

<pre class="sh_sh">
if [ -n "${prev_prev}" ]; then
#2nd layer
case "${prev_prev}" in
  create)
    case "${prev}" in
      avd)
         COMPREPLY=($(compgen -W "${create_avd_opts}" -- ${cur}))
         return 0
         ;;
      project)
         COMPREPLY=($(compgen -W "${create_project_opts}" -- ${cur}))
         return 0
         ;;
         ...
 esac
</pre>

<p>Depending in <strong>$prev_prev</strong>, <strong>$prev</strong> and <strong>$cur</strong> the correct list will be return, <strong>$ android subcomand option incomplete_option#CURSOR#</strong></p>

<pre class="sh_sh">
case "${prev}" in
    ##1st layer
    list)
        COMPREPLY=($(compgen -W "${list_opts}" -- ${cur}))
        return 0
        ;;
    create)
        COMPREPLY=($(compgen -W "${create_opts}" -- ${cur}))
        return 0
        ;;
    ...
</pre>

<p><strong>$ android subcommand incomplete_option#CURSOR#</strong></p>

<pre class="sh_sh">
      #general options
      case "${cur}" in
         -*)
             COMPREPLY=($(compgen -W "${OPTS}" -- ${cur}))
             ;;
         *)
             COMPREPLY=($(compgen -W "${COMMANDS}" -- ${cur}))
             ;;
      esac
}
complete -F \_android android
</pre>

<p><strong>$ android incomplete_subcommand#CURSOR#</strong></p>

<h3 id="extra">Extra</h3>

<h4 id="available-functions">Available functions</h4>

<p>There exist plenty of available functions who can be used to autocomplete commonly used options, for example, if a command accepts a <strong>-f</strong> option for file arguments, the <strong>_filedir</strong> function can be used:</p>

<pre class="sh_sh">
-f)
    \_filedir
    return 0
    ;;
</pre>

<p>Other pre-defined functions can be found at: <a href="http://anonscm.debian.org/gitweb/?p=bash-completion/bash-completion.git;a=blob;f=bash_completion">http://anonscm.debian.org/gitweb/?p=bash-completion/bash-completion.git;a=blob;f=bash_completion</a></p>

<h3 id="debug">Debug</h3>

<p>Bash autocompletion scripts are easy to create, however eventually (specially with larger cli commands) there are chances things doesn’t work as expected, in those cases enabling bash verbose mode is the easiest and faster method to debug such scripts:</p>

<pre class="sh_sh">
$ set -x
$ source ~/.bashrc #reload the environment
$ command opc[Tab][Tab] #testing the autocompletion
...
...
... verbose output
</pre>

<h3 id="examples">Examples</h3>

<p>There are many bash completion scripts in <a href="http://anonscm.debian.org/gitweb/?p=bash-completion/bash-completion.git;a=tree;f=completions">Internet</a> and <a href="https://github.com/javier-lopez/learn/tree/master/autocp/completions">some others</a> in my personal repository. Looking at examples is probably the easiest way to learn the harder details.</p>

<h3 id="final-thoughts">Final thoughts</h3>

<p>Bash autocompletion may seems scary at the beginning but once several examples are read a clear pattern can be dazzled, depending on your system usage they can save you a lot of time/typing, so next time you find yourself writing to much give them a shot and let the computer do the job for you 😊</p>

<ul>
  <li><a href="http://bash-completion.alioth.debian.org/">http://bash-completion.alioth.debian.org/</a></li>
</ul>

</div>

<div id="related">
  <h5>Related Entries:</h5>
  <ul class="related-posts">
    
    <li><span>22 Feb 2014</span> &raquo; <a href="/blog/en/2014/02/22/awk.html">the most portable language in the world, awk</a></li>
    
    <li><span>26 Jan 2014</span> &raquo; <a href="/blog/en/2014/01/26/introduction-to-drupal-7-installation-profiles.html">introduction to drupal 7 installation profiles</a></li>
    
    <li><span>22 Aug 2018</span> &raquo; <a href="/blog/en/2018/08/22/minos-a-tiling-wm-linux-distro.html">minos, a tiling wm linux distribution</a></li>
    
  </ul>
</div>

    <div id="disqus">
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'javierlopez'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
       var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
       dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
       (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
       })();
     </script>
     <noscript>Enable JavaScript to see/create comments</noscript>
    </div>


    </div>

    
<div id="footer">

  <div class="link" align="right">
    <a href="//javier.io/blog"><i class="icon-pencil"></i></a>
    <a href="//javier.io/pgp"><i class="icon-key"></i></a>
    <a href="//javier.io/twitter"><i class="icon-twitter"></i></a>
    <a href="//javier.io/github"><i class="icon-github-alt"></i></a>
  </div>
</div>

    

    <!-- syntax http://shjs.sourceforge.net/-->
    <script type="text/javascript" src="/assets/js/shjs/shjs_main.js"></script>

    <!-- lightbox http://gettopup.com, the other part of the lib is called in the post.html file-->
    <script type="text/javascript" src="/assets/js/top-up/top_up-min.js"></script>
    <script type="text/javascript">TopUp.host = "//javier.io/";</script>
    <script type="text/javascript">TopUp.images_path = "assets/js/top-up/images/";</script>
    <script type="text/javascript">
      TopUp.addPresets({
          "#content strong a": {
            readAltText: 1,
            effect: "clip",
            overlayClose: 0,
            shaded: 1,
            group: "img"
          }
    });
    </script>

    <!-- google analytics -->
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-47664650-1']);
      _gaq.push(['_trackPageview']);

      (function() {
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
       })();
    </script>

  </body>
</html>
